var s,n,e,a=(s,n,e)=>{if(!n.has(s))throw TypeError("Cannot "+e)},l=(s,n,e)=>(a(s,n,"read from private field"),e?e.call(s):n.get(s)),t=(s,n,e,l)=>(a(s,n,"write to private field"),l?l.call(s,e):n.set(s,e),e);import{V as i,u as o}from"./vendor.7737d109.js";!function(s=".",n="__import__"){try{self[n]=new Function("u","return import(u)")}catch(e){const a=new URL(s,location),l=s=>{URL.revokeObjectURL(s.src),s.remove()};self[n]=s=>new Promise(((e,t)=>{const i=new URL(s,a);if(self[n].moduleMap[i])return e(self[n].moduleMap[i]);const o=new Blob([`import * as m from '${i}';`,`${n}.moduleMap['${i}']=m;`],{type:"text/javascript"}),r=Object.assign(document.createElement("script"),{type:"module",src:URL.createObjectURL(o),onerror(){t(new Error(`Failed to import: ${s}`)),l(r)},onload(){e(self[n].moduleMap[i]),l(r)}});document.head.appendChild(r)})),self[n].moduleMap={}}}("assets/");const r=[["View the Source Code of This Page","https://github.com/vanillajsx/vanillajsx.github.io"],["GitHub Repository","https://github.com/vanillajsx/VanillaJSX"],["Join Discussions","https://github.com/vanillajsx/VanillaJSX/discussions"]],p=()=>{const s=i.r("div",{id:"h-menu-button"},i.r("span",null),i.r("span",null)),n=i.r("div",{id:"backfield"}),e=i.r("div",{class:"menu_list_container hidden"},s,i.r("div",{class:"menu-list"},r.map((s=>{const n=i.r("p",null,s[0]);return n.onclick=()=>window.open(s[1]),n}))),n);return o(e,"open",!1),e.watch("open",(s=>{s?e.classList.remove("hidden"):e.classList.add("hidden")})),n.onclick=()=>e.open=!1,s.onclick=()=>e.open=!e.open,e};const c=()=>i.r("header",null,i.r("div",{class:"_title_69m70_12"},"Vanilla.JSX"),i.r(p,null));const h="_main_8b2wh_1";class d extends HTMLElement{constructor(...a){super(...a),s.set(this,1),n.set(this,null),e.set(this,void 0),t(this,e,i.r("div",{part:"bar"}));this.attachShadow({mode:"closed"}).appendChild(l(this,e))}static get observedAttributes(){return["max","value"]}connectedCallback(){this.render()}attributeChangedCallback(e,a,i){switch(e){case"max":t(this,s,+i),this.render();break;case"value":t(this,n,Math.min(l(this,s),i)),this.render()}}render(){if(l(this,n)){this.classList.remove("indeterminate"),l(this,n)===l(this,s)&&this.classList.add("complete");const a=l(this,n)/l(this,s)*100;l(this,e).style.width=a+"%"}else l(this,e).style.width="",this.classList.remove("complete"),this.classList.add("indeterminate")}get value(){return l(this,n)}get max(){return l(this,s)}set value(s){this.setAttribute("value",s)}set max(s){this.setAttribute("max",s)}}s=new WeakMap,n=new WeakMap,e=new WeakMap,customElements.define("custom-progress",d);const u=({progValue:s=0,children:n=null})=>{const e=i.r(d,{max:"100",value:s}),a=i.r("button",null,"click"),l=i.r("div",{class:"t3"},a,e,((s,n)=>n.watch("progValue",(n=>s(n))))," %",n);return o(l,"progValue",s),l.watch("progValue",(s=>e.value=s)),a.onclick=()=>{l.progValue<100?l.progValue+=10:l.progValue=0},l};var m='<div class=\'center\'>\n\n<p><img src="./vjsx.svg" alt="logo"></p>\n<h1 id="welcome-to-vanillajsx">Welcome to VanillaJSX!</h1>\n<h3 id="just-a-pure-javascript-with-jsx-syntax">Just a pure Javascript with JSX syntax.</h3>\n<p>Code with pure Javascript, components, and JSX!</p>\n</div>\n\n\n<div class=\'boxed\' style=\'color: #a01232; font-size: larger; padding: 0.3rem;\'>\n\n<h3 id="⚠️caution⚠️">⚠️Caution⚠️</h3>\n<ul>\n<li>This is still in Draft phase!</li>\n</ul>\n</div>\n\n<hr>\n<h3 id="features">Features</h3>\n<ul>\n<li>Component Based Development!</li>\n<li>JSX syntax!</li>\n<li>NO complex framework!</li>\n<li>NO virtual DOMs! Just use your familiar HTML DOMs!</li>\n<li>No Re-rendering by its framework, easier for developers to understand the behavior</li>\n<li>Less Learning Difficulty than React</li>\n<li>Just use your JS skills!</li>\n<li>If you want to change DOM attributes or texts, JUST SET THEM BY YOURSELF!</li>\n<li>TS support</li>\n</ul>\n<h3 id="how-the-coding-works">How the Coding Works</h3>\n<p>When you code this:</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> elem1 = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;elem1&#x27;</span>&gt;</span>hi!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n</code></pre>\n<p>This will work as:</p>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> elem1 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>)\nelem1.append(<span class="hljs-string">&#x27;hi!&#x27;</span>)\nelem1.id = <span class="hljs-string">&#x27;elem1&#x27;</span>\n</code></pre>\n<hr>\n<h2 id="usage">Usage</h2>\n<h3 id="installation">Installation</h3>\n<pre><code class="language-sh">npm i @vanillajsx/vjsx\n</code></pre>\n<h3 id="for-vitejs">for <a href="https://vitejs.dev/">vitejs</a></h3>\n<p>in your <code>vite.config.js</code>:</p>\n<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">esbuild</span>: {\n    <span class="hljs-attr">jsxFactory</span>: <span class="hljs-string">&#x27;VJSX.r&#x27;</span>,\n    <span class="hljs-attr">jsxFragment</span>: <span class="hljs-string">&#x27;VJSX.Fragment&#x27;</span>,\n    <span class="hljs-attr">jsxInject</span>: <span class="hljs-string">`import VJSX from &#x27;@vanillajsx/vjsx&#x27;`</span>\n  },\n  <span class="hljs-comment">//... other settings</span>\n}\n</code></pre>\n<p>Then your JSX code would be interpreted as VanillaJSX! Have fun!</p>\n<hr>\n<h3 id="when-you-load-vanillajsx-library">When you load VanillaJSX library,</h3>\n<ul>\n<li><code>on</code> method, a shorthand of <code>addEventListener</code> \nis available on all the objects which provide &#39;addEventListener&#39;.</li>\n</ul>\n<h3 id="vanillajsx-provides">VanillaJSX provides:</h3>\n<ul>\n<li><code>useAttr</code> method:<pre><code class="language-ts"><span class="hljs-keyword">import</span> { useAttr } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vanillajsx/vjsx&#x27;</span>\nuseAttr(elem: Element, <span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">defaultValue</span>: <span class="hljs-built_in">any</span>)\n</code></pre>\n<ul>\n<li>This sets custom property variable on your element.</li>\n<li>This makes you able to listen the value change using <code>watch</code> listener:<pre><code class="language-ts">elem.watch(propName: <span class="hljs-built_in">string</span>, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> <span class="hljs-built_in">void</span>)\n</code></pre>\n<ul>\n<li><code>watch</code> listener is similar to <code>addEventListener</code> </li>\n<li>The difference is that the listener function in <code>watch</code> recieves the new property value, not <code>Event</code> object.</li>\n</ul>\n</li>\n<li>The code example below shows the usage of <code>useAttr</code> and <code>watch</code>.</li>\n</ul>\n</li>\n</ul>\n<p>You can code using function component, or using <a href="https://developer.mozilla.org/ja/docs/Web/Web_Components/Using_custom_elements">CustomElement</a></p>\n<h3 id="code-example">Code Example</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useAttr } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vanillajsx/vjsx&#x27;</span>\n<span class="hljs-keyword">import</span> CustomProgress <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./CustomProgress&#x27;</span>\n\n<span class="hljs-comment">//takes in attributes as arguments (access to children elements via &#x27;children&#x27; attribute)</span>\n<span class="hljs-keyword">const</span> Example = <span class="hljs-function">(<span class="hljs-params">{progValue=<span class="hljs-number">0</span>, children}</span>)=&gt;</span>{\n\n  <span class="hljs-comment">//declare elements</span>\n  <span class="hljs-keyword">const</span> progress = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomProgress</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&#x27;100&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{progValue}/</span>&gt;</span></span>\n  <span class="hljs-keyword">const</span> btn = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n  <span class="hljs-keyword">const</span> self = (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;t3&#x27;</span>&gt;</span>\n      {btn}\n      {progress} \n      {(set, elem)=&gt;elem.watch(&#x27;progValue&#x27;,v=&gt;set(v))} %\n      {children}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  )\n\n  <span class="hljs-comment">/*\n  below defines a property named &#x27;progValue&#x27;,\n  and when &#x27;progValue&#x27; changes, \n  all registered listeners will be executed.\n  */</span>\n  useAttr(self, <span class="hljs-string">&#x27;progValue&#x27;</span>, progValue)\n\n  <span class="hljs-comment">// functionalities</span>\n  <span class="hljs-comment">//when `self.progValue` changed, set `progress.value` to `self.progValue`</span>\n  self.watch(<span class="hljs-string">&#x27;progValue&#x27;</span>,<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span> progress.value = v)\n\n  btn.onclick = <span class="hljs-function">() =&gt;</span>{\n    <span class="hljs-comment">/*\n      below just looks assigning a value to a property,\n      however this is running getter/setter method,\n      which executes all listener functions registered via `watch` method.\n    */</span>\n    <span class="hljs-keyword">if</span>(self.progValue&lt;<span class="hljs-number">100</span>) self.progValue+=<span class="hljs-number">10</span>\n    <span class="hljs-keyword">else</span> self.progValue = <span class="hljs-number">0</span>\n  }\n\n  <span class="hljs-comment">// return self element</span>\n  <span class="hljs-keyword">return</span> self    \n}\n</code></pre>\n<h3 id="result-of-the-code-above">Result of the code above</h3>\n<div id=\'example-result-space\' class=\'boxed\'></div>\n\n<ul>\n<li>see how changing <code>self.progValue</code> affects other multiple values using <code>self.watch</code> method.</li>\n</ul>\n<hr>\n<h2 id="roadmap">Roadmap</h2>\n<ul>\n<li><input checked="" disabled="" type="checkbox"> VanillaJSX processor<ul>\n<li>it dynamically appends components</li>\n</ul>\n</li>\n<li><input disabled="" type="checkbox"> make Typescript code suggestion work<ul>\n<li>maybe making VSCode Extension might be a solution</li>\n</ul>\n</li>\n<li><input disabled="" type="checkbox"> Vite.js HMR Plugin</li>\n<li><input disabled="" type="checkbox"> SSG builder<ul>\n<li>it generates <ul>\n<li>pre-rendered HTML</li>\n<li>JS files which initializes the components</li>\n</ul>\n</li>\n<li><a href="https://vitejs.dev/guide/ssr.html#ssr-specific-plugin-logic">ViteJS SSG loader</a></li>\n</ul>\n</li>\n</ul>\n';const g=()=>i.r("div",{class:`container ${h}`},((s,n)=>{m.split("<hr>").forEach((s=>n.appendChild(i.r("section",{innerHTML:s,class:"markdown-body"})))),n.querySelector("#example-result-space").appendChild(i.r(u,null))}));document.querySelector("#app").appendChild(i.r("div",null,i.r(c,null),i.r(g,null)));
